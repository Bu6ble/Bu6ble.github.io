<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>安装教程</title>
    <url>/HEXO/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/HEXO%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>HEXO+NODEJS</p>
<h2 id="关于NVM安装Node-js问题"><a href="#关于NVM安装Node-js问题" class="headerlink" title="关于NVM安装Node.js问题"></a>关于NVM安装Node.js问题</h2><h3 id="‘node’不是内部或外部命令，也不是可运行的程序或批处理文件"><a href="#‘node’不是内部或外部命令，也不是可运行的程序或批处理文件" class="headerlink" title="‘node’不是内部或外部命令，也不是可运行的程序或批处理文件"></a>‘node’不是内部或外部命令，也不是可运行的程序或批处理文件</h3><p>安装了nvm，但是输入node -v显示如下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240814150345364.png"
                      alt="image-20240814150345364"
                ></p>
<p>解决方案：</p>
<p><strong>卸载重装</strong>。查了教程，有所最好卸载之前用nvm所有安装的node版本，我只安装了一个，所以没进行这样的操作。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm uninstall v18.19.0   // 这里根据所需输入版本号</span><br></pre></td></tr></table></figure></div>

<p>接着，可以进行重装。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install v18.19.0   // 这里根据所需输入版本号</span><br><span class="line">nvm use v18.19.0	   // 使用</span><br></pre></td></tr></table></figure></div>



<h2 id="关于镜像问题"><a href="#关于镜像问题" class="headerlink" title="关于镜像问题"></a>关于镜像问题</h2><h3 id="问题1：使用nvm-ls-available-命令无可供下载的版本"><a href="#问题1：使用nvm-ls-available-命令无可供下载的版本" class="headerlink" title="问题1：使用nvm ls available 命令无可供下载的版本"></a>问题1：使用nvm ls available 命令无可供下载的版本</h3><p>想要安装NVM，有可能遇到一个bug，使用 nvm ls available 命令进行查看可供下载的版本，但是输出的表格为空。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240815103940625.png"
                      alt="image-20240815103940625"
                ></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>对于中国用户而言，可以切换<code>nodejs</code>或<code>npm</code>的镜像地址来访问，即在命令行执行如下命令</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm node_mirror https://npmmirror.com/mirrors/node/</span><br><span class="line">nvm npm_mirror https://npmmirror.com/mirrors/npm/</span><br></pre></td></tr></table></figure></div>

<p>再次运行<code>nvm ls available</code> ，已经可以完整展示可供下载的版本了：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240815104142621.png"
                      alt="image-20240815104142621"
                ></p>
<h3 id="问题2：使用npm-install时，显示ETIMEDOUT"><a href="#问题2：使用npm-install时，显示ETIMEDOUT" class="headerlink" title="问题2：使用npm install时，显示ETIMEDOUT"></a>问题2：使用npm install时，显示ETIMEDOUT</h3><p>访问<code>https://registry.npmjs.org</code>这个地址需要翻墙才能访问，所以在国内经常会出现连接超时等问题。为了解决这个问题，可以将npm的源设置为国内的镜像例如淘宝镜像。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240814142612039.png"
                      alt="image-20240814142612039"
                ></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//将npm设置为淘宝镜像</span><br><span class="line">npm config set registry https://registry.npmmirror.com</span><br><span class="line"></span><br><span class="line">//输入上述命令后，npm就会将镜像源设置为淘宝镜像，可以一下命令来验证即查看npm镜像设置</span><br><span class="line">npm config get registry</span><br><span class="line">//如果输出结果为 https://registry.npmmirror.com/，则说明已经成功设置镜像源</span><br><span class="line"></span><br><span class="line">//尝试重新执行，应该就能够成功安装了</span><br><span class="line">npm install</span><br><span class="line"></span><br><span class="line">//另外，如果不想全局设置 npm 的镜像源，也可以在执行 npm install 命令时指定镜像源，例如：</span><br><span class="line">npm install --registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240814143744955.png"
                      alt="image-20240814143744955"
                ></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="关于NVM使用小技巧"><a href="#关于NVM使用小技巧" class="headerlink" title="关于NVM使用小技巧"></a>关于NVM使用小技巧</h2><h3 id="使用nrm管理npm源"><a href="#使用nrm管理npm源" class="headerlink" title="使用nrm管理npm源"></a>使用nrm管理npm源</h3><p>针对需要在不同的网络环境之间切换时，允许在不同的 npm 源之间进行切换，以加快包的下载速度，或者解决特定源无法访问的问题。</p>
<p>nrm 提供了一组命令，可以列出可用的 npm 源、添加新源、测试源的响应速度，并切换当前使用的源。</p>
<p>安装命令：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g nrm</span><br></pre></td></tr></table></figure></div>

<p>一些nrm命令：</p>
<ul>
<li><p>列出可用的源：当前配置的所有可用 npm 源以及它们的名称和 URL。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm ls</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240815105424191.png"
                      alt="image-20240815105424191"
                ></p>
</li>
<li><p>切换源：将当前的 npm 源切换为指定的源。可用npm源的名称或 URL 作为参数。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm use &lt;registry&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>添加源：添加一个新的 npm 源并指定其名称和 URL。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm add &lt;registry&gt; &lt;url&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除源：删除指定的 npm 源，需要提供源的名称或 URL 作为参数。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm del &lt;registry&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>测试源的速度：测试指定源的响应速度，并显示测试结果。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm test &lt;registry&gt;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>显示当前使用的源：当前正在使用的 npm 源的名称和 URL。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nrm current</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="使用nvm安装node版本"><a href="#使用nvm安装node版本" class="headerlink" title="使用nvm安装node版本"></a>使用nvm安装node版本</h3><ul>
<li>查询可插入版本号，LST表示可插入的稳定版本</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm list available</span><br></pre></td></tr></table></figure></div>

<ul>
<li>指定安装版本</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm install &lt;version&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>切换到所需版本</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm use &lt;version&gt;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看当前node和npm版本信息</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></div>

<ul>
<li>查看已安装版本</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm list</span><br></pre></td></tr></table></figure></div>

<ul>
<li>删除某个版本</li>
</ul>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvm uninstall &lt;version&gt;</span><br></pre></td></tr></table></figure></div>



<h2 id="关于hexo使用主题报错问题"><a href="#关于hexo使用主题报错问题" class="headerlink" title="关于hexo使用主题报错问题"></a>关于hexo使用主题报错问题</h2><h3 id="版本不匹配"><a href="#版本不匹配" class="headerlink" title="版本不匹配"></a>版本不匹配</h3><p>一定要注意hexo的版本和Node.js版本的匹配</p>
<p>不匹配的话，报的错误都不知道怎么解决…</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\yuanqi\AppData\Roaming\Typora\typora-user-images\image-20240814144016012.png"
                      alt="image-20240814144016012"
                ></p>
<h3 id="安装后本地可以运行，但是推送到GIT上JS-CSS失效，状态码报404"><a href="#安装后本地可以运行，但是推送到GIT上JS-CSS失效，状态码报404" class="headerlink" title="安装后本地可以运行，但是推送到GIT上JS&#x2F;CSS失效，状态码报404"></a>安装后本地可以运行，但是推送到GIT上JS&#x2F;CSS失效，状态码报404</h3><p><code>_config.yml</code>中的url根据样例，添加了一个project，但是如果在根路径下创建的，所以样式和js会404。<br>解决方案：修改<code>_config.yml</code>中的url。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span><br><span class="line">url: https://你的github账户名.github.io</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure></div>



<h3 id="使用主题显示“warning-LF-will-be-replaced-by-CRLF”"><a href="#使用主题显示“warning-LF-will-be-replaced-by-CRLF”" class="headerlink" title="使用主题显示“warning: LF will be replaced by CRLF”"></a>使用主题显示“warning: LF will be replaced by CRLF”</h3><p>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add . 时出现提示。</p>
<p>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，所以当项目文件里有用的地方使用LF作为换行符，这个时候再继续git add或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符。</p>
<p>只是一个警告信息，忽略就可以了。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 以下任选其一禁用自动转换 </span><br><span class="line">// 关闭自动转换（当前仓库）</span><br><span class="line">git config core.autocrlf false</span><br><span class="line">// 关闭自动转换（全局仓库）</span><br><span class="line">git config --global core.autocrlf false </span><br><span class="line">// 检查git的设置结果</span><br><span class="line">git config core.autocrlf</span><br></pre></td></tr></table></figure></div>

<p>参考链接</p>
<ol>
<li><a class="link"   href="https://www.cnblogs.com/Fooo/p/17864023.html" >安装NVM之后，NODE -V 提示‘NODE‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>使用github pages和hexo搭建个人博客并绑定域名[<a class="link"   href="https://blog.csdn.net/weixin_44826970/article/details/120044020]" >https://blog.csdn.net/weixin_44826970/article/details/120044020]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
<li>Git提示“warning: LF will be replaced by CRLF”最详细解释+解决方案[<a class="link"   href="https://zhuanlan.zhihu.com/p/586324681]" >https://zhuanlan.zhihu.com/p/586324681]<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>HEXO</category>
        <category>使用教程</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>HEXO使用指南</title>
    <url>/HEXO/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/HEXO%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。 </p>
<p>Hexo 使用Markdown（或其他标记语言）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>欢迎使用 Hexo，本文档将帮助您快速上手：<a class="link"   href="https://hexo.io/zh-cn/docs/index.html" >https://hexo.io/zh-cn/docs/index.html<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<p> 仅以此文记录一些在使用期间需要用到的内容。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="初始创建用法"><a href="#初始创建用法" class="headerlink" title="初始创建用法"></a>初始创建用法</h2><h3 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h3><ul>
<li>打开命令行，进入博客所在文件夹的<strong>根目录</strong>，执行下述命令。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在<code>source/categories</code>下找到<code>index.md</code>文件，可得到内容如下。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-03 22:53:43</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改内容如下。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类（可自定义）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-03 22:53:43</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>打开需要分类的文章，在文章开头添加<code>Front Matter</code>格式。<ul>
<li>这里要注意，一篇文章只能属于一个分类</li>
<li>如果需要分类嵌套，则继续添加“-xxx”。如下所示，为该文章属于“HEXO”下的“使用教程”分类</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">HEXO使用指南</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-05 21:54:35</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">HEXO</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">使用教程</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>根据上述操作则给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。</li>
<li>只有添加了<code>categories: xxx</code>的文章才会被收录到首页的“分类”中。</li>
</ul>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ul>
<li>打开命令行，进入博客所在文件夹的<strong>根目录</strong>，执行下述命令。</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></div>

<ul>
<li>在<code>source/categories</code>下找到<code>index.md</code>文件，可得到内容如下。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-03 22:53:43</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>修改内容如下。</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签（可自定义）</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-03 22:53:43</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>打开需要加标签的文章，在文章开头添加<code>Front Matter</code>格式。<ul>
<li>这里要注意，一篇文章只能属于一个分类</li>
<li>如果需要分类嵌套，则继续添加“-xxx”。如下所示，为该文章属于“HEXO”下的“使用教程”分类</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">HEXO使用指南</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2024-12-05 21:54:35</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">HEXO</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">使用教程</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">environment</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>根据上述操作则给文章添加标签，点击首页的“标签”可以看到该标签下的所有文章。</li>
<li>只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</li>
</ul>
]]></content>
      <categories>
        <category>HEXO</category>
        <category>使用教程</category>
      </categories>
      <tags>
        <tag>environment</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora添加行内公式语法格式</title>
    <url>/%E7%BB%84%E4%BB%B6%E5%BA%93/Typora%E6%B7%BB%E5%8A%A0%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<p>首先需要点击typora文件-偏好设置-Markdown-Markdown拓展语法-勾选内联公式-关闭typora-再重新启动。</p>
<p>输入两个美元符号($$)，在两个美元符号中间输入公式，即$公式$。</p>
<p>详细版：<a class="link"   href="https://zhuanlan.zhihu.com/p/261750408" >https://zhuanlan.zhihu.com/p/261750408<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> </p>
<h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171446000.png"
                      alt="image-20241211171446000"
                ></p>
<h2 id="省略号"><a href="#省略号" class="headerlink" title="省略号"></a>省略号</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171534624.png"
                      alt="image-20241211171534624"
                ></p>
<h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171601424.png"
                      alt="image-20241211171601424"
                ></p>
<h2 id="累加"><a href="#累加" class="headerlink" title="累加"></a>累加</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171638223.png"
                      alt="image-20241211171638223"
                ></p>
<h2 id="累乘"><a href="#累乘" class="headerlink" title="累乘"></a>累乘</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171833722.png"
                      alt="image-20241211171833722"
                ></p>
<h2 id="集合符号"><a href="#集合符号" class="headerlink" title="集合符号"></a>集合符号</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171735941.png"
                      alt="image-20241211171735941"
                ></p>
<h2 id="帽子-尖角-符号"><a href="#帽子-尖角-符号" class="headerlink" title="帽子(尖角)符号"></a>帽子(尖角)符号</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241211171753536.png"
                      alt="image-20241211171753536"
                ></p>
]]></content>
      <categories>
        <category>组件库</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/uncategorized/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
]]></content>
  </entry>
  <entry>
    <title>深度学习概论</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h1><h2 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/2d52e7542bc42c19a95cdbfc9c6bfd22.png"
                      alt="img"
                ></p>
<ul>
<li>以上为一个简单的神经网络概述，将房屋的面积作为神经网络的输入（我们称之为x），通过一个节点（一个小圆圈），最终输出了价格（用y表示）。其实这个小圆圈就是一个单独的神经元。接着网络实现了这个函数的功能。</li>
<li>从趋近于零开始，到变成一条直线。这个函数被称作<strong>ReLU激活函数</strong>，它的全称是Rectified Linear Unit。rectify（修正）可以理解成max(0,x)，这也是得到一个这种形状的函数的原因。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241208210847590.png"
                      alt="image-20241208210847590"
                ></p>
<ul>
<li>不仅仅用房屋的面积来预测它的价格，现在有了一些有关房屋的其它特征，比如卧室的数量、一家人的数量也会影响房屋价格。</li>
<li>邮政编码或许能作为一个特征，告诉你步行化程度。比如这附近是不是高度步行化，你是否能步行去杂货店或者是学校，以及你是否需要驾驶汽车。有些人喜欢居住在以步行为主的区域，另外根据邮政编码还和富裕程度相关或体现出附近学校的水平有多好。</li>
<li>在图上每一个画的小圆圈都可以是<strong>ReLU</strong>的一部分，也就是指修正线性单元，或者其它稍微非线性的函数。基于房屋面积和卧室数量，可以估算家庭人口；基于邮编，可以估测步行化程度或者学校的质量。这些决定人们乐意花费多少钱。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241208213813019.png"
                      alt="image-20241208213813019"
                ></p>
<ul>
<li>对于一个房子来说，家庭人口、步行化程度以及学校的质量都能帮助你预测房屋的价格。以此为例，x是所有的这四个输入，y是你尝试预测的价格，把这些单个的神经元叠加在一起，就有了一个稍微大一点的神经网络。</li>
<li>神经网络的一部分神奇之处在于，当你实现它之后，你要做的只是输入x，就能得到输出 y。因为它可以自己计算你训练集中样本的数目以及所有的中间过程。同时也注意到这些被叫做隐藏单元圆圈，在一个神经网络中，它们每个都从输入的四个特征获得自身输入，比如说，第一个结点代表家庭人口，而家庭人口仅仅取决于x1和x2特征。</li>
<li>换句话说，在神经网络中，你决定在这个结点中想要得到什么，然后用所有的四个输入来计算想要得到的。因此，我们说输入层和中间层被紧密的连接起来了。</li>
</ul>
<h2 id="用神经网络进行监督学习"><a href="#用神经网络进行监督学习" class="headerlink" title="用神经网络进行监督学习"></a>用神经网络进行监督学习</h2><ul>
<li><p>对于图像应用，我们经常在神经网络上使用卷积（<strong>Convolutional Neural Network</strong>），通常缩写为<strong>CNN</strong>。</p>
</li>
<li><p>对于序列数据，经常使用<strong>RNN</strong>，一种递归神经网络（<strong>Recurrent Neural Network</strong>），语言，英语和汉语字母表或单词都是逐个出现的，所以语言也是最自然的序列数据，因此更复杂的<strong>RNNs</strong>版本经常用于这些应用。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241209193508722.png"
                      alt="image-20241209193508722"
                ></p>
</li>
<li><p>对于结构化数据和非结构化数据</p>
<ul>
<li>结构化数据意思是每个特征，比如说房屋大小卧室数量，或者是一个用户的年龄，都有一个很好的定义。</li>
<li>非结构化数据是指比如原始音频或者你想要识别的图像或文本中的内容，特征可能是图像中的像素值或文本中的单个单词。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241209193638681.png"
                      alt="image-20241209193638681"
                ></p>
<ul>
<li>【如红线所示】为传统机器学习算法的性能。作为数据量的一个函数，你可能得到一个弯曲的线，就像图中这样，它的性能一开始在增加更多数据时会上升，但是一段变化后它的性能就会像一个高原一样。假设你的水平轴拉的很长很长，它们不知道如何处理规模巨大的数据。</li>
<li>而过去十年的社会里，我们遇到的很多问题只有相对较少的数据量。随着数字化时代的到来，我们便收集到了大量的数据，远超过机器学习算法能够高效发挥它们优势的规模。</li>
<li>【如黄线所示】如果训练一个小型的神经网络，那么这个性能可能会像下图黄色曲线表示那样。</li>
<li>【如蓝线所示】如果训练一个稍微大一点的神经网络，比如说一个中等规模的神经网络，它在某些数据上面的性能也会更好一些。</li>
<li>【如绿线所示】如果你训练一个非常大的神经网络，它就会变成下图绿色曲线那样，并且保持变得越来越好。</li>
<li>综上所述，如果想要获得较高的性能体现，那么有两个条件要完成，第一个是需要训练一个规模足够大的神经网络，以发挥数据规模量巨大的优点，其次是需要能画到x轴的这个位置，所以需要很多的数据。</li>
<li>如今最可靠的方法来在神经网络上获得更好的性能，往往就是<strong>要么训练一个更大的神经网络，要么投入更多的数据</strong>。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241209194443467.png"
                      alt="image-20241209194443467"
                ></p>
<ul>
<li><p>在这个小的训练集中，各种算法的优先级事实上定义并不明确，所以如果你没有大量的训练集，那效果会取决于你的特征工程能力，那将决定最终的性能。</p>
</li>
<li><p>神经网络方面的一个巨大突破是从<strong>sigmoid</strong>函数转换到一个<strong>ReLU</strong>函数。</p>
</li>
<li><p>使用<strong>sigmoid</strong>函数的问题是，在这个区域，<strong>sigmoid</strong>函数的梯度会接近零，所以学习的速度会变得非常缓慢，因为当你实现梯度下降以及梯度接近零的时候，参数会更新的很慢，所以学习的速率也会变得很慢。</p>
</li>
<li><p>而通过改变这个被叫做激活函数的东西，神经网络换用这一个函数，叫做<strong>ReLU</strong>的函数（修正线性单元），<strong>ReLU</strong>它的梯度对于所有输入的负值都是零，因此梯度更加不会趋向逐渐减少到零。</p>
</li>
<li><p>从左图可以看出来，在正值区域，sigmoid函数的斜率趋近于0，而ReLU函数的斜率为正值，仅仅通过将<strong>sigmoid</strong>函数转换成<strong>ReLU</strong>函数，便能够使得一个叫做梯度下降（<strong>gradient descent</strong>）的算法运行的更快。</p>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241209195354125.png"
                      alt="image-20241209195354125"
                ></p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>吴恩达《神经网络与深度学习》</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络基础</title>
    <url>/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E3%80%8A%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E3%80%8B/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="二元分类"><a href="#二元分类" class="headerlink" title="二元分类"></a>二元分类</h2><ul>
<li>逻辑回归是一个用于二分类(<strong>binary classification</strong>)的算法。</li>
<li>举个例子，假如你有一张图片作为输入，比如一只猫，如果识别这张图片为猫，则输出标签1作为结果；如果识别出不是猫，那么输出标签0作为结果。</li>
<li>一张图片在计算机中是如何表示的，为了保存一张图片，需要保存三个矩阵，它们分别对应图片中的红、绿、蓝三种颜色通道，如果你的图片大小为64x64像素，那么你就有三个规模为64x64的矩阵，分别对应图片中红、绿、蓝三种像素的强度值。</li>
<li>为了便于表示，这里画了三个很小的矩阵，注意它们的规模为5x4 而不是64x64。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241210211233889.png"
                      alt="image-20241210211233889"
                ></p>
<ul>
<li>为了把这些像素值放到一个特征向量中，我们需要把这些像素值提取出来，然后放入一个特征向量 x 。<ul>
<li>为了把这些像素值转换为特征向量 x ，需要像上述这样定义一个特征向量x来表示这张图片，把所有的像素都取出来，例如255、231等等，直到取完所有的红色像素，接着最后是255、134、…、255、134等等，直到得到一个特征向量，把图片中所有的红、绿、蓝像素值都列出来。</li>
<li>如果图片的大小为64x64像素，那么向量x的总维度，将是64乘以64乘以3，这是三个像素矩阵中像素的总量。在这个例子中结果为$n_x$ &#x3D; 12288</li>
</ul>
</li>
<li>因此，在二分类问题中，我们的目标就是学习到分类器，它以图片的特征向量作为输入，然后预测输出 y，结果为1还是0，也就是预测图片中是否有猫。</li>
<li>下图引入一些符号定义：<ul>
<li>用一对 ( x , y ) 来表示一个单独的样本。</li>
<li>训练样本个数：M<del>train</del></li>
<li>测试样本个数：M<del>test</del></li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/1733838516807.png"
                      alt="1733838516807"
                ></p>
<ul>
<li>为了能把训练集表示得更紧凑一点，我们会定义一个矩阵用大写的X表示。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:\Users\Bubb1e\AppData\Roaming\Typora\typora-user-images\image-20241210215417716.png"
                      alt="image-20241210215417716"
                ></p>
<ul>
<li>X是一个规模为$n_x$乘以m的矩阵，当使用X.shape的Python命令时，可显示矩阵的规模，即X.shape等于（$n_x$，m）。</li>
<li>而对于y的定义，则是一个规模为1乘以m的矩阵，同时也可以使用y.shape的Python命令计算可得。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241210220150785.png"
                      alt="image-20241210220150785"
                ></p>
<h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><ul>
<li><p>对于二元分类问题来讲，给定一个输入特征向量$X$，它可能对应一张图片，你想识别这张图片识别看它是否是一只猫或者不是一只猫的图片，你想要一个算法能够输出预测，你只能称之为 $\hat{y}$ ，也就是你对实际值 $y$ 的估计。</p>
</li>
<li><p>更正式地来说，你想让 $\hat{y}$ 表示 $y$ 等于 1 的一种可能性，前提条件是给定了输入特征 $X$。</p>
</li>
<li><p>$X$ 是一个 $n_x$ 维的向量（相当于有$n_x$个特征的特征向量）， 用 $w$ 表示逻辑回归的参数，也是一个 $n_x$ 维的向量（因为 $w$ 是特征权重，维度与特征向量相同），参数里面还有 $b$，这是一个实数（表示偏差）。所以给出输入 $X$  以及参数 $w$ 和 $b$  之后，我们怎样产生输出预测值  $\hat{y}$ ，一件你可以尝试却不可行的事是让  $\hat{y}$ &#x3D; $w^T x + b$。</p>
</li>
<li><p>这时候我们得到的是一个关于输入$X$的线性函数，实际上这是你在做线性回归时所用到的，但是这对于二元分类问题来讲不是一个非常好的算法。因为你想要 $\hat{y}$ 表示实际值 $y$ 等于1的几率的话， $\hat{y}$ 应该在0到1之间。但是$w^T x + b$是一个可能比1大得多，甚至是一个负值。</p>
</li>
<li><p>对于你想要的在0和1之间的概率来说它是没有意义的，因此在逻辑回归中，我们的输出 $\hat{y}$，应该是等于由上面得到的线性函数式子作为自变量的sigmoid函数中，公式下所示：**$\hat{y}$ &#x3D; $\sigma (w^T x + b)$**。 ，将线性函数转换为非线性函数。</p>
</li>
<li><p>下图是sigmoid函数的图像，如果我把水平轴作为 $z$ 轴，那么关于 $z$ 的sigmoid函数是平滑地从0到1。通常用 $z$ 来表示 $w^T x + b$ 的值。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/0102a11a2b72c38eabc4882d11a2c8b9.png"
                      alt="img"
                ></p>
</li>
<li><p>关于sigmoid函数的公式是这样的：$\sigma(z)&#x3D;\frac{1}{1 + e^{-z}}$</p>
<ul>
<li>在这里 $z$ 是一个实数</li>
<li>如果 $z$ 非常大，那么 $e^{-z}$ 将会接近于0，关于 $z$ 的sigmoid函数将会近似等于1除以1加上某个非常接近于0的项，因为 $e$ 的指数如果是个绝对值很大的负数的话，这项将会接近于0，所以如果z很大的话，那么关于z 的sigmoid函数会非常接近1。</li>
<li>如果 $z$ 非常小或者说是一个绝对值很大的负数，那么关于 $e^{-z}$ 这项会变成一个很大的数，即1除以一个非常非常大的数，所以这个就接近于0。</li>
<li>因此当你实现逻辑回归时，你的工作就是去让机器学习参数  $w$  以及 $b$ 这样才使得 $\hat{y}$ 成为 $y &#x3D;1$ 这一情况的概率的一个很好的估计。</li>
</ul>
</li>
</ul>
<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><ul>
<li><strong>为什么需要代价函数：</strong>为了训练逻辑回归模型的参数 $w$ 和参数 $b$，我们需要一个代价函数，通过训练代价函数来得到参数 $w$ 和参数 $b$。</li>
<li>看一下逻辑回归的输出函数：</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/ce5234c8312fe79de93e44b31b75e859.png"
                      alt="img"
                ></p>
<ul>
<li><p>为了让模型通过学习调整参数，你需要给予一个 $m$ 本的训练集，这会让你在训练集上找到参数 $w$ 和参数 $b$，来得到你的输出。</p>
</li>
<li><p>对训练集的预测值，我们将它写成 $\hat{y}$，我们更希望它会接近于训练集中的 $y$ 值。</p>
</li>
<li><p>使用这些带有圆括号的上标来区分索引和样本，训练样本 $i$ 所对应的预测值为 ${y}^{(i)}$，是用训练样本 $ \mathbf{w}^T \mathbf{x}^{(i)} + b $ 通过sigmoid函数来得到，也可以将 $z$ 定义为 $ {z}^{(i)} &#x3D; \mathbf{w}^T \mathbf{x}^{(i)} + b $ 。因此，可以明确，上标 $(i)$ 是用来指明数据表示 $x$ 或者 $y$ 或者 $z$ 获取其他数据的第 $i$ 个训练样本。</p>
</li>
<li><p>损失函数又叫做误差函数，用来衡量算法的运行情况，即 **Loss function：$L(\hat{y},y)$**。</p>
</li>
<li><p>一般通过这个称为 $L$ 的损失函数，来衡量预测输出值和实际值有多接近。一般我们用预测值和实际值的平方差或者它们平方差的一半，但是通常在逻辑回归中不这么做。</p>
<ul>
<li>因为在逻辑回归参数中，会发现优化目标不是凸优化，只能找到多个局部最优值，梯度下降法很可能找不到全局最优值，虽然平方差是一个不错的损失函数，但是在逻辑回归模型中会定义另外一个损失函数。</li>
</ul>
</li>
<li><p>我们在逻辑回归中用到的损失函数是：<br>$$<br>L(\hat{y}, y) &#x3D; -y \log(\hat{y}) - (1 - y) \log(1 - \hat{y})<br>$$</p>
</li>
<li><p>为什么要用这个函数作为逻辑损失函数？当我们使用平方误差作为损失函数的时候，你会想要让这个误差尽可能地小，对于这个逻辑回归损失函数，我们也想让它尽可能地小，为了更好地理解这个损失函数怎么起作用，我们举两个例子。</p>
<ul>
<li>当 $y &#x3D;1$时损失函数 $y &#x3D; - \log(\hat{y})$，如果想要损失函数 $L$  尽可能得小，那么 $\hat{y}$ 就要尽可能大，因为sigmoid函数取值 [0,1]，所以， $\hat{y}$ 会无限接近于1。</li>
<li>当 $y &#x3D;0$ 时损失函数 $y &#x3D; - \log(1 - \hat{y})$ ，如果想要损失函数 $L$  尽可能得小，那么 $\hat{y}$ 就要尽可能小，因为sigmoid函数取值 [0,1]，所以 $\hat{y}$ 会无限接近于0。</li>
</ul>
</li>
<li><p>因此，我们可以看见，如果 $y&#x3D;1$，则会尽可能让 $\hat{y}$ 变大，如果 $y&#x3D;0$，则会尽可能让 $\hat{y}$ 变小。</p>
</li>
<li><p>损失函数是在单个训练样本中定义的，它衡量的是算法在单个训练样本中表现如何，为了衡量算法在全部训练样本上的表现如何，需要定义一个算法的代价函数，是对 $m$ 个样本的代价函数求和然后除以 $m$。</p>
</li>
</ul>
<p>$$<br>J(w, b) &#x3D; \frac{1}{m} \sum_{i &#x3D; 1}^{m} L(\hat{y}^{(i)}, y^{(i)}) &#x3D; \frac{1}{m} \sum_{i &#x3D; 1}^{m} (-y^{(i)} \log \hat{y}^{(i)} - (1 - y^{(i)}) \log (1 - \hat{y}^{(i)}))<br>$$</p>
<h2 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h2><ul>
<li>梯度下降法可以做什么？<ul>
<li>在测试集上，通过最小化代价函数（成本函数） $J(w, b) $ 来训练参数 $w$ 和 $b$</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/7d7e8d051e62e36a9ae62b8302145c9d.png"
                      alt="img"
                ></p>
<ul>
<li><p><strong>梯度下降法的形象化说明</strong></p>
<ul>
<li>定义 $w$ 和 $b$ ，都是单一实数，代价函数（成本函数）$J(w, b) $ 是水平轴上 $w$ 和 $b$ 上的曲面，因此曲面的高度就是$J(w, b) $ 在某一点的函数值。</li>
<li>我们所做的就是找到使得代价函数（成本函数）$J(w, b) $ 函数值是最小值，对应的参数 $w$ 和 $b$ 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/image-20241212163325610.png"
                      alt="image-20241212163325610"
                ></p>
<ul>
<li>如图所示，代价函数（成本函数）$J(w, b) $ 是一个凸函数，像一个大碗一样。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/47f5a006bee9579d26947c9bd0f66478.png"
                      alt="img"
                ></p>
<ul>
<li>如图，这就与刚才的图有些相反，因为它是非凸的并且有很多不同的局部最小值。由于逻辑回归的代价函数（成本函数）$J(w, b) $ 特性，我们必须定义代价函数（成本函数）$J(w, b) $ 为凸函数。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/cb9bd747634f0168bd22b9270d29f1a8.png"
                      alt="img"
                ></p>
<ul>
<li>初始化 $w$ 和 $b$  ，可以用如图那个小红点来初始化参数，也可以采用随机初始化的方法，对于逻辑回归几乎所有的初始化方法都有效，因为函数是凸函数，无论在哪里初始化，应该达到同一点或大致相同的点。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/1fb24081b3bc79e0913502427b5fa4be.png"
                      alt="img"
                ></p>
<ul>
<li>我们以如图的小红点的坐标来初始化参数 $w$ 和 $b$ 。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/a05187bbd232fc8565856b0998186e51.png"
                      alt="img"
                ></p>
<ul>
<li>朝最陡的下坡方向走一步，不断地迭代。我们朝最陡的下坡方向走一步，如图，走到了如图中第二个小红点处。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/ed6cdc26dfe1a0ef78d0ad696ebd7c32.png"
                      alt="img"
                ></p>
<ul>
<li>我们可能停在这里也有可能继续朝最陡的下坡方向再走一步，如图，经过两次迭代走到第三个小红点处。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://cdn.jsdelivr.net/gh/Bu6ble/Pictures@main/img/792ecdcf33787b3e3c9fc8d1d7b9d1a9.png"
                      alt="img"
                ></p>
<ul>
<li><strong>直到走到全局最优解或者接近全局最优解的地方</strong>。通过以上的三个步骤我们可以找到全局最优解，也就是代价函数（成本函数）$J(w, b) $ 这个凸函数的最小值点。</li>
</ul>
</li>
</ul>
<p>​	</p>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>吴恩达《神经网络与深度学习》</category>
      </categories>
      <tags>
        <tag>deep learning</tag>
      </tags>
  </entry>
</search>
